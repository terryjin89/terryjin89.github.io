---
layout: single
title:  "SQL main command"
category: language
tag: [SQL, command]
---
# SQL 주요 명령어 완벽 가이드

SQL(Structured Query Language)은 관계형 데이터베이스를 관리하기 위한 표준 언어입니다. 주요 명령어들을 카테고리별로 정리해보겠습니다.

## 1. DDL (Data Definition Language) - 데이터 정의어

데이터베이스 구조를 정의하고 변경하는 명령어들입니다.

### CREATE - 생성
**개념**: 데이터베이스, 테이블, 인덱스 등을 생성합니다.

```sql
-- 데이터베이스 생성
CREATE DATABASE company;

-- 테이블 생성
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    age INT CHECK (age >= 18),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE DEFAULT CURRENT_DATE
);

-- 인덱스 생성
CREATE INDEX idx_department ON employees(department);

-- 뷰 생성
CREATE VIEW high_salary_employees AS
SELECT name, department, salary 
FROM employees 
WHERE salary > 50000;
```

### ALTER - 수정
**개념**: 기존 테이블의 구조를 변경합니다.

```sql
-- 컬럼 추가
ALTER TABLE employees ADD COLUMN phone VARCHAR(20);

-- 컬럼 수정
ALTER TABLE employees MODIFY COLUMN salary DECIMAL(12,2);

-- 컬럼 이름 변경
ALTER TABLE employees RENAME COLUMN emp_id TO employee_id;

-- 컬럼 삭제
ALTER TABLE employees DROP COLUMN phone;

-- 제약조건 추가
ALTER TABLE employees ADD CONSTRAINT fk_dept 
FOREIGN KEY (department) REFERENCES departments(dept_name);
```

### DROP - 삭제
**개념**: 데이터베이스 객체를 완전히 삭제합니다.

```sql
-- 테이블 삭제
DROP TABLE employees;

-- 데이터베이스 삭제
DROP DATABASE company;

-- 인덱스 삭제
DROP INDEX idx_department ON employees;

-- 뷰 삭제
DROP VIEW high_salary_employees;
```

### TRUNCATE - 초기화
**개념**: 테이블의 모든 데이터를 빠르게 삭제합니다 (구조는 유지).

```sql
-- 테이블 데이터 전체 삭제 (롤백 불가)
TRUNCATE TABLE employees;
```

## 2. DML (Data Manipulation Language) - 데이터 조작어

데이터를 추가, 수정, 삭제하는 명령어들입니다.

### INSERT - 데이터 삽입
**개념**: 테이블에 새로운 행을 추가합니다.

```sql
-- 단일 행 삽입
INSERT INTO employees (name, email, age, department, salary) 
VALUES ('김철수', 'kim@company.com', 30, 'IT', 55000.00);

-- 여러 행 동시 삽입
INSERT INTO employees (name, email, age, department, salary) VALUES 
('이영희', 'lee@company.com', 28, 'HR', 45000.00),
('박민수', 'park@company.com', 35, 'Sales', 48000.00),
('최지영', 'choi@company.com', 32, 'IT', 60000.00);

-- 다른 테이블에서 데이터 복사
INSERT INTO employees_backup 
SELECT * FROM employees WHERE department = 'IT';

-- 일부 컬럼만 삽입 (나머지는 DEFAULT 또는 NULL)
INSERT INTO employees (name, department) 
VALUES ('홍길동', 'Marketing');
```

### SELECT - 데이터 조회
**개념**: 테이블에서 데이터를 검색하고 조회합니다.

```sql
-- 전체 데이터 조회
SELECT * FROM employees;

-- 특정 컬럼만 조회
SELECT name, department, salary FROM employees;

-- 조건부 조회
SELECT * FROM employees WHERE age > 30;
SELECT * FROM employees WHERE department = 'IT' AND salary > 50000;

-- 정렬
SELECT * FROM employees ORDER BY salary DESC;
SELECT * FROM employees ORDER BY department ASC, salary DESC;

-- 제한된 개수 조회
SELECT * FROM employees LIMIT 5;
SELECT * FROM employees LIMIT 5 OFFSET 10; -- 11번째부터 5개

-- 그룹화 및 집계함수
SELECT department, COUNT(*) as emp_count, AVG(salary) as avg_salary
FROM employees 
GROUP BY department
HAVING AVG(salary) > 50000;

-- 조인
SELECT e.name, e.salary, d.dept_name 
FROM employees e
INNER JOIN departments d ON e.department = d.dept_code;

-- 서브쿼리
SELECT * FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);
```

### UPDATE - 데이터 수정
**개념**: 기존 데이터를 수정합니다.

```sql
-- 단일 행 수정
UPDATE employees 
SET salary = 58000 
WHERE emp_id = 1;

-- 여러 컬럼 동시 수정
UPDATE employees 
SET salary = salary * 1.1, department = 'Senior IT'
WHERE department = 'IT' AND age > 30;

-- 조건부 수정
UPDATE employees 
SET salary = CASE 
    WHEN department = 'IT' THEN salary * 1.15
    WHEN department = 'Sales' THEN salary * 1.10
    ELSE salary * 1.05
END;

-- 다른 테이블의 값으로 수정
UPDATE employees e
SET salary = (
    SELECT avg_salary 
    FROM department_salary ds 
    WHERE ds.dept = e.department
);
```

### DELETE - 데이터 삭제
**개념**: 테이블에서 행을 삭제합니다.

```sql
-- 조건부 삭제
DELETE FROM employees WHERE age < 20;

-- 여러 조건으로 삭제
DELETE FROM employees 
WHERE department = 'Temp' AND hire_date < '2023-01-01';

-- 서브쿼리로 삭제
DELETE FROM employees 
WHERE salary < (SELECT AVG(salary) FROM employees);

-- 조인을 사용한 삭제
DELETE e FROM employees e
INNER JOIN departments d ON e.department = d.dept_code
WHERE d.status = 'CLOSED';
```

## 3. DQL (Data Query Language) - 데이터 질의어

### 고급 SELECT 구문들

#### DISTINCT - 중복 제거
```sql
-- 중복 제거
SELECT DISTINCT department FROM employees;
SELECT DISTINCT department, age FROM employees;
```

#### WHERE 절의 다양한 조건
```sql
-- 범위 조건
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;

-- 목록 조건
SELECT * FROM employees WHERE department IN ('IT', 'Sales', 'HR');

-- 패턴 매칭
SELECT * FROM employees WHERE name LIKE '김%';        -- '김'으로 시작
SELECT * FROM employees WHERE email LIKE '%@gmail.com'; -- gmail로 끝남
SELECT * FROM employees WHERE name LIKE '_철_';        -- 가운데가 '철'

-- NULL 체크
SELECT * FROM employees WHERE phone IS NULL;
SELECT * FROM employees WHERE phone IS NOT NULL;
```

#### 집계 함수 (Aggregate Functions)
```sql
-- 기본 집계함수
SELECT COUNT(*) as total_employees FROM employees;
SELECT COUNT(phone) as employees_with_phone FROM employees;
SELECT SUM(salary) as total_salary FROM employees;
SELECT AVG(salary) as average_salary FROM employees;
SELECT MIN(age) as youngest_age FROM employees;
SELECT MAX(salary) as highest_salary FROM employees;

-- 그룹별 집계
SELECT department, 
       COUNT(*) as emp_count,
       AVG(salary) as avg_salary,
       MIN(salary) as min_salary,
       MAX(salary) as max_salary
FROM employees 
GROUP BY department;
```

#### 조인 (JOIN)
```sql
-- INNER JOIN - 두 테이블에 모두 존재하는 데이터만
SELECT e.name, e.salary, d.dept_name
FROM employees e
INNER JOIN departments d ON e.department = d.dept_code;

-- LEFT JOIN - 왼쪽 테이블의 모든 데이터
SELECT e.name, COALESCE(d.dept_name, '부서없음') as department
FROM employees e
LEFT JOIN departments d ON e.department = d.dept_code;

-- RIGHT JOIN - 오른쪽 테이블의 모든 데이터
SELECT e.name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.department = d.dept_code;

-- FULL OUTER JOIN - 양쪽 테이블의 모든 데이터
SELECT e.name, d.dept_name
FROM employees e
FULL OUTER JOIN departments d ON e.department = d.dept_code;

-- SELF JOIN - 같은 테이블끼리 조인
SELECT e1.name as employee, e2.name as manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.emp_id;
```

## 4. DCL (Data Control Language) - 데이터 제어어

데이터베이스 접근 권한을 관리하는 명령어들입니다.

### GRANT - 권한 부여
```sql
-- 사용자 생성
CREATE USER 'developer'@'localhost' IDENTIFIED BY 'password123';

-- SELECT 권한 부여
GRANT SELECT ON company.employees TO 'developer'@'localhost';

-- 여러 권한 동시 부여
GRANT SELECT, INSERT, UPDATE ON company.* TO 'developer'@'localhost';

-- 모든 권한 부여
GRANT ALL PRIVILEGES ON company.* TO 'admin'@'localhost';

-- 권한 부여 후 적용
FLUSH PRIVILEGES;
```

### REVOKE - 권한 취소
```sql
-- 특정 권한 취소
REVOKE INSERT ON company.employees FROM 'developer'@'localhost';

-- 모든 권한 취소
REVOKE ALL PRIVILEGES ON company.* FROM 'developer'@'localhost';
```

## 5. TCL (Transaction Control Language) - 트랜잭션 제어어

트랜잭션의 실행, 취소, 확정을 제어하는 명령어들입니다.

### COMMIT - 트랜잭션 확정
```sql
START TRANSACTION;

INSERT INTO employees (name, department, salary) 
VALUES ('신입사원', 'IT', 35000);

UPDATE employees SET salary = salary * 1.1 WHERE department = 'IT';

-- 모든 변경사항 확정
COMMIT;
```

### ROLLBACK - 트랜잭션 취소
```sql
START TRANSACTION;

DELETE FROM employees WHERE department = 'IT';

-- 실수했다면 모든 변경사항 취소
ROLLBACK;
```

### SAVEPOINT - 중간 저장점
```sql
START TRANSACTION;

INSERT INTO employees (name, department, salary) VALUES ('직원1', 'IT', 40000);

SAVEPOINT sp1;

INSERT INTO employees (name, department, salary) VALUES ('직원2', 'HR', 35000);

SAVEPOINT sp2;

DELETE FROM employees WHERE salary < 30000;

-- sp2까지만 롤백 (마지막 DELETE만 취소)
ROLLBACK TO sp2;

-- 최종 확정
COMMIT;
```

## 6. 고급 SQL 기능

### 서브쿼리 (Subquery)
```sql
-- WHERE절 서브쿼리
SELECT * FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);

-- SELECT절 서브쿼리
SELECT name, salary, 
       (SELECT AVG(salary) FROM employees) as company_avg
FROM employees;

-- FROM절 서브쿼리
SELECT dept, avg_salary 
FROM (
    SELECT department as dept, AVG(salary) as avg_salary
    FROM employees 
    GROUP BY department
) as dept_stats
WHERE avg_salary > 50000;

-- EXISTS
SELECT * FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e 
    WHERE e.department = d.dept_code
);
```

### 윈도우 함수 (Window Functions)
```sql
-- 순위 함수
SELECT name, salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num,
       RANK() OVER (ORDER BY salary DESC) as rank_num,
       DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;

-- 부서별 순위
SELECT name, department, salary,
       RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees;

-- 누적 집계
SELECT name, salary,
       SUM(salary) OVER (ORDER BY salary) as running_total,
       AVG(salary) OVER (ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg
FROM employees;
```

### CASE 문
```sql
-- 단순 CASE
SELECT name, salary,
       CASE 
           WHEN salary >= 60000 THEN '고급'
           WHEN salary >= 45000 THEN '중급'
           ELSE '초급'
       END as salary_grade
FROM employees;

-- 검색 CASE
SELECT name, department,
       CASE department
           WHEN 'IT' THEN '기술부'
           WHEN 'HR' THEN '인사부'
           WHEN 'Sales' THEN '영업부'
           ELSE '기타부서'
       END as dept_korean
FROM employees;
```

### CTE (Common Table Expression)
```sql
-- 단순 CTE
WITH high_earners AS (
    SELECT * FROM employees WHERE salary > 50000
)
SELECT department, COUNT(*) as count
FROM high_earners
GROUP BY department;

-- 재귀 CTE
WITH RECURSIVE emp_hierarchy AS (
    -- 최상위 관리자
    SELECT emp_id, name, manager_id, 1 as level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 하위 직원들
    SELECT e.emp_id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    INNER JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT * FROM emp_hierarchy ORDER BY level, name;
```

## 실무 활용 예시

### 1. 데이터 분석 쿼리
```sql
-- 부서별 연봉 통계
SELECT 
    department,
    COUNT(*) as 직원수,
    MIN(salary) as 최저연봉,
    MAX(salary) as 최고연봉,
    AVG(salary) as 평균연봉,
    STDDEV(salary) as 연봉편차
FROM employees 
GROUP BY department
ORDER BY 평균연봉 DESC;
```

### 2. 데이터 정제 쿼리
```sql
-- 중복 데이터 제거
DELETE e1 FROM employees e1
INNER JOIN employees e2 
WHERE e1.emp_id > e2.emp_id 
AND e1.email = e2.email;
```

### 3. 마이그레이션 쿼리
```sql
-- 기존 테이블에서 새 테이블로 데이터 이관
INSERT INTO employees_new (name, email, department, salary)
SELECT name, email, dept_code, salary * 1.1
FROM employees_old e
INNER JOIN dept_mapping d ON e.old_dept = d.old_code;
```

이러한 SQL 명령어들을 잘 활용하면 데이터베이스를 효율적으로 관리하고 필요한 정보를 정확하게 추출할 수 있습니다. 실무에서는 이들을 조합하여 복잡한 비즈니스 로직을 구현하게 됩니다.